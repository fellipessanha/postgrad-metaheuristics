\documentclass[12pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazilian]{babel}
\usepackage[style=abnt]{biblatex}
\addbibresource{references.bib}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{float}
\usepackage{multirow}

\geometry{margin=2.5cm}

% Code listing style
\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{orange},
}

% Title
\title{Metaheurísticas para Problemas de Otimização Combinatória:\\
Dependência de Pacotes e Mochila com Penalidades}
\author{Fellipe Sanha}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
    Este trabalho apresenta a implementação e análise de metaheurísticas para dois problemas de otimização
    combinatória: o Problema da Dependência de Pacotes e o Problema da Mochila com Penalidades (KPF). São exploradas
    abordagens de Programação Linear Inteira (ILP) e o algoritmo BRKGA (Biased Random-Key Genetic Algorithm), com
    comparação de desempenho em instâncias de diferentes tamanhos.
\end{abstract}

\tableofcontents
\newpage

\section{Introdução}

Neste trabalho abordaremos a descrição de variações de um NP difíceis, similar ao Problema da Mochila(Knapsack
Problem - KP), estratégias viáveis para resolver este problema em diferentes recortes temporais, e comparamos os
resultados obtidos frente aos resultados ótimos conhecidos na literatura.

\section{Problema da Mochila com Penalidades (Knapsack Problem with Forfeits - KPF)}

O problema abordado é definido sobre um conjunto $I$ de itens, com cada item $i$ é associado a um peso $w_i$ e um
benefício $p_i \in \mathbb{N}$, consiste em encontrar um subconjunto $I' \subseteq I$, sujeito a:

\begin{enumerate}
    \item A soma dos pesos dos itens escolhidos não ultrapassarem a capacidade $H \in \mathbb{N}$
    \item Para um conjunto $F$ de pares de itens $f$, associa-se uma penalidade $d_f$ ao um par de itens
          $f = \{i, j\} \subseteq I$. Caso a solução avaliada contenha este par, ela deve ter a penalidade decrementada de
          seu benefício total.

\end{enumerate}

Desta maneira, o \textit{custo} podemos formular as restrições do problema como

\begin{align}
    \sum_{i=1}^{n} w_i x_i & \leq H                                   \\
    x_i + x_j - v_f        & \leq 1, \quad \forall f = \{i, j\} \in F \\
    x_i                    & \in \{0, 1\}, \quad \forall i            \\
    v_f                    & \in [0, 1], \quad \forall f \in F
    \label{eq_restrictions}
\end{align}

E a função de objetivo como:
\begin{equation}
    \max \sum_{i=1}^{n} p_i x_i - \sum_{f \in F} d_f v_f
    \label{eq_objective}
\end{equation}

Esta formulação foi apresentada pela primeira vez por~\cite{cerulli2020knapsack}, onde foi definido pela primeira vez
o Problema da Mochila com Penalidades.

\section{Soluções Propostas}

Neste capítulo as soluções propostas para o problema serão exploradas, onde os detalhes de implementação e as
estratégias escolhidas para tentar elevar os desempenhos serão comentadas.

\subsection{Programação Linear Inteira (ILP)}

A formulação ILP segue o modelo de Cerulli et al. \cite{cerulli2020knapsack}, utilizando as equações de modelagem da
seção acima. A motivação por trás do uso desta solução foram de poder testar soluções fora do escopo de
metaheurísticas, e de poder se aproveitar de uma solução que pode garantir otimalidade para o problema.

Outro fator determinante foi a facilidade e confiabilidade da implementação, fazendo uso do framework
JuMP\cite{Lubin2023}, de programação matemática para a linguagem de programação Julia. A implementação foi feita
utilizando o solver open source HiGHS\cite{huangfu2018highs}, que já vem integrado por padrão junto à biblioteca
do JuMP.

A fim de acelerar a convergência do solver, utilizamos uma técnica de \textit{warm start}~\cite{yildirim2002warm}, onde
uma solução com algum nível de qualidade é fornecido ao solver, permitindo-o ignorar todas as soluções de avaliação
inferior mais facilmente.

A solução inicial utilizada no warm start foi gerada usando um algoritmo guloso randomizado, onde a solução melhora
avaliada era escolhida entre alguns samples gerados com diferentes valores de $\alpha$.


\subsection{BRKGA (Biased Random-Key Genetic Algorithm)}

O Algoritmo Genético de Chaves Enviesadas Aleatórias (Biased Random-Key Genetic Algorithm - BRKGA) é um algoritmo
baseado no Algoritmo Genético de Chaves Aleatórias, com uma diferenciação na maneira com que os \textit{pais} são
escolhidos em uma dada população~\cite{gonccalves2011biased}

O algoritmo consiste em gerar uma população de soluções aleatória, \textit{decodificar} esta população, isto é,
gerar a representação da solução equivalente, avaliar todos os indivíduos e, similar ao processo de
\textit{sobrevivência dos mais aptos}, gerar uma nova população, onde os melhores candidatos têm mais influência.

Um diferencial da implementação desenvolvida foi o fato de que as populações iniciais era geradas através de um
GRASP, com um $\alpha$ configurável nos parâmetros. Isso fez com que as soluções iniciais já tivessem uma
qualidade maior, mas sem perder o elemento da aleatoriedade, tão importante em metaheurísticas.

A implementação do algoritmo é proprietária, desenvolvida para uma disciplina sobre metaheurísticas na Universidade
Federal Fluminense - UFF, pensada inicialmente para o Problema da Mochila com uniões de conjuntos (Set-Union Knapsack
Problem - SUKP), mas desenvolvido de maneira genérica para ser utilizado em qualquer problema que fosse descrito
seguindo a interface sugerida pelo programa.

Podemos ver nas tabelas~\ref{generic_interface_table}~e~\ref{brkga_interface_table}

\begin{table}[H]
    \centering
    \begin{tabular}{l|p{10cm}}
        \toprule
        \textbf{Nome}             & \textbf{Descrição}                                                                                               \\
        \midrule
        \texttt{ProblemContext}   & Representa informações de contexto do problema, como capacidade da mochila, pesos e benefícios de itens, etc.    \\
        \midrule
        \texttt{Solution}         & Representa uma solução para o problema                                                                           \\
        \midrule
        \texttt{EncodingStrategy} & Representa uma estratégia de encoding                                                                            \\
        \midrule
        \texttt{evaluate}         & Função que recebe o contexto do problema e uma solução, e retorna um número representando a qualidade da solução \\
        \bottomrule
    \end{tabular}
    \caption{Detalhes sobre a interface genérica da implementação do BRKGA}
    \label{generic_interface_table}
\end{table}


\begin{table}[H]
    \centering
    \begin{tabular}{l|p{12cm}}
        \toprule
        \textbf{Nome}   & \textbf{Descrição}                                                                       \\
        \midrule
        \texttt{encode} & Função que recebe um \texttt{ProblemContext} e um \texttt{EncodingStrategy} que gera uma
        população nova e transforma sua representação usual em uma representação de chaves                         \\
        \midrule
        \texttt{decode} & que recebe um \texttt{ProblemContext}, uma combinação de chaves representada por um
        \texttt{Array}, e um \texttt{EncodingStrategy} e retorna a representação usual da combinação de chaves informada
        \\
        \bottomrule
    \end{tabular}
    \caption{Detalhes sobre a interface específica do BRKGA}
    \label{brkga_interface_table}
\end{table}

Na tabela~\ref{brkga_params_table} podemos ver as configurações dos parâmetros utilizados pelo BRKGA. Estes parâmetros foram calibrados de modo que
o maior fator de parada era o tempo de execução. Também podemos ver, nos parâmetros abaixo, a variável $\alpha$, usada
no algoritmo GRASP de geração de novos indivíduos.

\begin{table}[H]
    \centering
    \begin{tabular}{ll}
        \toprule
        \textbf{Parâmetro}   & \textbf{Valor} \\
        \midrule
        Tamanho da população & 1000           \\
        Viés de crossover    & 0.5            \\

        $\alpha$ (GRASP)     & 0.7            \\
        Iterações máximas    & 50000          \\
        \bottomrule
    \end{tabular}
    \caption{Parâmetros do BRKGA}
    \label{brkga_params_table}
\end{table}

\section{Comparação de resultados}

Nesta seção veremos os desempenhos das diferentes estratégias desenvolvidas. Comparamos, também, os resultados com os
ótimos conhecidos da literatura~\cite{moura2021ils}. Todos os algoritmos foram executados em uma máquina 11th Gen Intel
Core i7-1165G7 de décima primeira geração, com 4 núcleos e 8 processadores lógicos


\subsection{Instâncias de Teste}

Foram escolhidas vinte instâncias no total, de quatro tamanhos diferentes, 500 itens, 700 itens, 800 itens, e 1000 itens
, visando avaliar o desempenho dos algoritmos desenvolvidos desde instâncias relativamente pequenas(500 itens) até
tamanhos considerados grandes(1000 itens).

\subsection{Comparação com ótimos globais}

\begin{table}[H]
    \centering
    \small
    \begin{tabular}{cc|r|rr|rr|rr}
        \toprule
                              &                    &                & \multicolumn{2}{c|}{\textbf{60s}} & \multicolumn{2}{c|}{\textbf{120s}} & \multicolumn{2}{c}{\textbf{180s}}                                                   \\
        \textbf{Tamanho}      & \textbf{Instância} & \textbf{Ótimo} & ILP                               & BRKGA                              & ILP                               & BRKGA         & ILP             & BRKGA         \\
        \midrule
        \multirow{5}{*}{500}  & 1                  & 2626           & 2145                              & \textbf{2244}                      & \textbf{2336}                     & 2244          & \textbf{ 2336 } & 2244          \\
                              & 2                  & 2660           & \textbf{2308}                     & 2238                               & \textbf{2324}                     & 2238          & \textbf{2419}   & 2242          \\
                              & 3                  & 2516           & \textbf{2207}                     & 2152                               & \textbf{2299}                     & 2163          & \textbf{2310}   & 2198          \\
                              & 4                  & 2556           & \textbf{2233}                     & 2170                               & \textbf{2254}                     & 2170          & \textbf{2445}   & 2185          \\
                              & 5                  & 2625           & \textbf{2297}                     & 2199                               & \textbf{2353}                     & 2199          & \textbf{2409}   & 2218          \\
        \midrule
        \multirow{5}{*}{700}  & 1                  & 3589           & \textbf{3156}                     & 3059                               & \textbf{3218}                     & 3059          & 3\textbf{299}   & 3059          \\
                              & 2                  & 3679           & 2763                              & \textbf{2857}                      & 2775                              & 2\textbf{857} & \textbf{2913}   & 2857          \\
                              & 3                  & 3664           & \textbf{3128}                     & 3124                               & \textbf{3189}                     & 3124          & \textbf{3206}   & 3124          \\
                              & 4                  & 3647           & \textbf{3182}                     & 3085                               & \textbf{3267}                     & 3085          & \textbf{3267}   & 3085          \\
                              & 5                  & 3596           & \textbf{3188}                     & 3082                               & \textbf{3156}                     & 3082          & \textbf{3128}   & 3082          \\
        \midrule
        \multirow{5}{*}{800}  & 1                  & 4184           & \textbf{3400}                     & 3398                               & 3400                              & \textbf{3427} & \textbf{3520}   & 3427          \\
                              & 2                  & 4065           & 3300                              & \textbf{3371}                      & 3299                              & \textbf{3371} & 3299            & \textbf{3371} \\
                              & 3                  & 4104           & \textbf{3475}                     & 3316                               & \textbf{3475}                     & 3388          & \textbf{3475}   & 3388          \\
                              & 4                  & 4056           & 3218                              & \textbf{3349}                      & 3252                              & \textbf{3349} & 3320            & \textbf{3349} \\
                              & 5                  & 4086           & 3366                              & \textbf{3389}                      & 3366                              & \textbf{3389} & 3386            & \textbf{3389} \\
        \midrule
        \multirow{5}{*}{1000} & 1                  & 4940           & 3852                              & \textbf{4028}                      & 3916                              & \textbf{4077} & 3928            & \textbf{4077} \\
                              & 2                  & 4969           & 4034                              & \textbf{4105}                      & 4034                              & \textbf{4105} & 4034            & \textbf{4105} \\
                              & 3                  & 5177           & 4040                              & \textbf{4230}                      & 4211                              & \textbf{4230} & 4273            & \textbf{4230} \\
                              & 4                  & 5143           & 4091                              & \textbf{4235}                      & 4137                              & \textbf{4302} & 4212            & \textbf{4302} \\
                              & 5                  & 5136           & 4094                              & \textbf{4143}                      & 4019                              & \textbf{4145} & 4040            & \textbf{4145} \\
        \bottomrule
    \end{tabular}
    \caption{Resultados comparativos por tamanho de instância e tempo limite}
\end{table}

\subsection{Gaps médios por tamanho de instância}

\begin{table}[H]
    \centering
    \small
    \begin{tabular}{c|rr|rr|rr}
        \toprule
                         & \multicolumn{2}{c|}{\textbf{60s}} & \multicolumn{2}{c|}{\textbf{120s}} & \multicolumn{2}{c}{\textbf{180s}}                                                    \\
        \textbf{Tamanho} & ILP                               & BRKGA                              & ILP                               & BRKGA          & ILP            & BRKGA          \\
        \midrule
        500              & \textbf{13.79}                    & 15.24                              & \textbf{10.88}                    & 15.15          & \textbf{8.17}  & 14.58          \\
        700              & \textbf{15.13}                    & 16.31                              & \textbf{14.1}                     & 16.31          & \textbf{12.97} & 16.31          \\
        800              & 18.23                             & \textbf{17.91}                     & 18.07                             & \textbf{17.42} & \textbf{17.06} & 17.42          \\
        1000             & 19.81                             & \textbf{18.23}                     & 20.22                             & \textbf{17.76} & 19.82          & \textbf{17.76} \\
        \bottomrule
    \end{tabular}
    \caption{GAP comparativo por tamanho de instância}
\end{table}

\section{Conclusão}

Neste trabalho foram apresentadas e comparadas duas abordagens para resolver o Problema da Mochila com Penalidades
(KPF): Programação Linear Inteira (ILP) utilizando o solver HiGHS, e o algoritmo metaheurístico BRKGA.

Os resultados experimentais demonstraram que o desempenho relativo das abordagens varia conforme o tamanho da
instância e o tempo disponível para execução. Para instâncias menores (500 e 700 itens), a abordagem ILP apresentou
gaps médios inferiores, beneficiando-se de que o tempo necessário para convergir em instâncias menores também é menor
para soluções de melhor qualidade. Já para instâncias maiores (800 e 1000 itens), o BRKGA demonstrou superioridade,
mantendo gaps mais consistentes mesmo com o aumento da complexidade do problema.

A técnica de warm start aplicada ao solver ILP, utilizando soluções geradas por um algoritmo guloso randomizado,
mostrou-se eficaz para acelerar a convergência inicial. Da mesma forma, a estratégia de inicialização da população
do BRKGA através do GRASP contribuiu para a qualidade das soluções encontradas.

Como trabalhos futuros, sugere-se a exploração de:
\begin{itemize}
    \item Melhorar as estratégias de crossover e os critérios de avaliação da geração da solução inicial,
          possibilitando assim uma variabilidade ainda maior entre as soluções inicial geradas por mutação
    \item Calibração automática e eficiente dos parâmetros do BRKGA através de técnicas como irace ou SMAC,
          ou uma calibração paramétrica, que por exemplo varie o tamanho do $\alpha$ utilizado no GRASP varie com o tamanho
          da instância
    \item Implementação de operadores de busca local para refinamento das soluções do BRKGA
    \item Avaliação em instâncias de maior porte para verificar a escalabilidade das abordagens
\end{itemize}

\printbibliography

\end{document}
